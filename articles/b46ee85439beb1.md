---
title: "Promiseとモナド： then と async/await の選び方"
emoji: "👏"
type: "tech"
topics: [TypeScript, JavaScript, Promise, Monad]
published: true
---

何度目の議論なのかという感じだが、全員こうすべきというような主張ではなくて、あくまで自分の意見を残すためのドキュメント。

## tl;dr

`async/await` と `then` は表面的には等価だが、設計や保守の観点では明確なトレードオフがある。
制約が強いほど安全性が高く、予期せぬ副作用を避けやすい。
よって、原則として関数合成（`then`）を採用し、どうしても中間変数が必要な箇所のみ `async` によるdo記法を用いるべきだと考えている。

# `Promise` とモナド：`then` と `async/await` の選び方

`Promise` や一般的なモナドを扱う際、主に2種類の記法が存在する。（ポイントフリースタイル云々は取り合えず忘れる）

1. **do記法 / for内包表記**（`async/await`など）
2. **メソッドチェーンによる関数合成**（`then` / `map`など）

両者は多くのケースで等価に書けるが、それぞれに得意・不得意がある。本稿ではそれらの違い、トレードオフ、そして選択方針について考える。

## 等価なコードの比較

次の2つは、挙動として等価なコードになる。

### 1. `async/await`（do記法）

```ts
async function fetch() {
  const user = await fetchUser()
  const posts = await fetchPosts(user.id)
  return posts
}
```

### 2. `then` チェーン

```ts
const fetch = () =>
  fetchUser()
    .then(user => fetchPosts(user.id))
```

どちらも `fetchUser()` の結果を使って `fetchPosts()` を呼び、値を返す流れになっている。
可読性については、せいぜい好みの差になっている。

## `then` の弱点：中間変数の再利用

`then` では「中間変数を複数の箇所で再利用する」ようなケースに弱い。

### 例：同じ値を2箇所で使いたい

```ts
async function complexLogic() {
  const config = await fetchConfig()
  const a = await stepA(config)
  const b = await stepB(config, a)
  return finalize(a, b)
}
```

これを `then` チェーンで書こうとすると、`config` をスコープ外に逃すか、ネストを深くするしかなく、明確に可読性が落ちる。

```ts
const complexLogic = () =>
  fetchConfig().then(config =>
    stepA(config).then(a =>
      stepB(config, a).then(b =>
        finalize(a, b)
      )
    )
  )
```

もしくは状態を外に（mutable な変数を利用するため、安全ではない）

```ts
let currentConfig
let currentA

fetchConfig()
  .then(config => {
    currentConfig = config
    return stepA(config)
  })
  .then(a => {
    currentA = a
    return stepB(currentConfig, a)
  })
  .then(b => finalize(currentA, b))
```

## メリット・デメリットの比較
### do記法（async/await）
#### メリット:
- 複数の中間値を再利用できる（代入された変数を好きな場所で使える）
- 手続き的な思考と相性がよく、処理が読みやすい場合がある
- スコープの共有が容易で、複雑な依存関係を持つ処理が書きやすい
- 制約が `then` より緩いため、どんな状況でも利用できる

#### デメリット:
- 全体がひとつのスコープに収束し、変数のスコープが広くなる
- 処理の分割や抽出が比較的にしづらく、リファクタビリティが低下しやすい
- 大きな1関数になりやすいため、並列処理との親和性が低い（やろうとすれば可能だが、より臨機応変に書き換える必要がある）

### メソッドチェーン（then）
#### メリット:
- 変数スコープが強制的に狭くなるため、安全性が高い
- チェーンを部分的に別関数するなど、関数単位での分割が容易
- 副作用を明示しやすく、データフローが関数的に設計できる
- 小さい純粋な関数の組み合わせになるため、並列処理の設計や改変がしやすい

#### デメリット:
- 中間値を複数使う場合の記述が煩雑になりやすい（事実上できない）

## 閑話：安全で質の高いコードとは何か？

安全で質の高いコードとは「制約が強い」コードである。
型が厳密に定義され、スコープが狭く、状態が閉じていることによって、バグを未然に防ぎ、分割可能にし、保守性を高める。

`then` チェーンでは、変数が関数スコープに閉じるため、他の箇所に影響を及ぼしにくい。関数型プログラミングが好まれるのも、こうした制約の強さによってコードの質が担保されるからだ。
一方で、強い制約はある種の書きにくさを生む。特に初学者など制約に対するメンタルモデルがない場合には、動作するコードを書きにくいという事態が発生する。

一方、`async/await` は自由度が高く、スコープが広がるため、将来の編集時に意図しない変数の使い回しや副作用、関数の肥大化を起こしやすくなる。
ルールの緩さは書きやすさにつながるが、それは同時にコードの品質を下げるという構造がある（必ずしもそうではないが）。

## 自分の方針

基本的には `then` などのメソッドチェーンを使っている。
理由は以下の通り：

* 変数のスコープが狭くなることで意図が明確になる
* 好きな位置で `.then()` チェーンを切り出して関数化できる

ただし、同じ変数を複数回参照する必要がある場合に限り `async/await` を選ぶ。特に、変数部分に依存があるところだけ切り出して、別の `async function` とする。
それ以外で `async` を使うことは極力避ける。

## 他の感想
- `Promise` 等の非同期処理だけ特別扱いして `async/await` を用意せずに、一般にモナドとしてまとめて実装して欲しい（ Haskell や Scala を除く）
