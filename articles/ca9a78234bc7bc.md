---
title: "行同士の依存関係を考える"
emoji: "👋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [javascript, dependency, refactoring]
published: true
published_at: 2025-07-25 07:12
---

## tl;dr

コードを書くとき、自分には矢印が見えている。

それは、**ある行が他の行に依存している**ことを意味する矢印で、変数の定義、関数の呼び出し、副作用。すべてがどこかに矢印を伸ばしている。

この矢印の数や長さ、複雑さをなるべく減らすようにすると、コードは格段に読みやすく、壊れにくくなる。

## 行と行のあいだの矢印

たとえば以下のようなコードを見てみよう。

```ts
const a = 3;
const b = a + 1;
const c = b * 2;
console.log(c);
````

このコードの行や変数には、明確な依存関係がある：

* `b` は `a` に依存している
* `c` は `b` に依存している
* `console.log` は `c` に依存している

つまり、次のような**依存の矢印**が見える：

![行単位の依存の矢印](/images/ca9a78234bc7bc/example.png)

これは簡単な例だが、現実のコードではもっと複雑な矢印が錯綜する。モジュールやクラス同士などの依存関係は一般的にも良く語られているが、行や変数単位で観察したことは少ない人も多いのではないか。

## 矢印が多く、複雑だと、コードは読みにくく壊れやすくなる

依存の矢印が多い、あるいは遠くまで飛んでいると、コードは以下のような問題を抱えるようになる：

* **読みづらい**：一行を理解するのに、前後の10行を読まなければならない
* **修正しづらい**：一箇所の修正が思わぬ箇所に影響を与える

結果として、**スパゲッティコード**が生まれる。

## グローバル変数は「矢印の出所が不明」になる

グローバル変数は、矢印の観点では最悪に近い。

```ts
let sharedState = 0;

function increment() {
  sharedState += 1;
}
```

![グローバル変数への矢印](/images/ca9a78234bc7bc/example2.png)

この `increment()` 関数は、外部にある `sharedState` に依存している。

だがその依存は、**関数の中からは見えない**。`sharedState` がどこで定義され、どこで変更されているかは、**別の場所を探さなければ分からない**。

これは「謎の矢印をエスパーして探す」ような状態だ。また、これはグローバル変数の再代入に限らず、一般の副作用で起きていることだ。

## 再代入は依存の矢印をねじらせる

コードの中で**同じ変数に再代入**すると、依存関係はさらに複雑になる。

```ts
let score = 0;
if (user.isPremium) {
  score += 100;
}
if (user.hasCoupon) {
  score += 50;
}
```

この `score` は、複数の条件に応じて変化する。
依存グラフで描くと、次のように**複数の経路から再代入されている状態**になる：

```
      ┌────────────┐
user →│ if-premium │
      └────┬───────┘
           ▼
        score
           ▲
      ┌────┴───────┐
user  │ if-coupon  │
      └────────────┘
```

この構造は、**値の由来を理解するのが難しく**、後から読んだときに「どうしてこの値になったのか？」を追いかける必要がある。

### 再代入を避けると、矢印は単純になる

```ts
const base = 0;
const premiumBonus = user.isPremium ? 100 : 0;
const couponBonus = user.hasCoupon ? 50 : 0;
const score = base + premiumBonus + couponBonus;
```

このように再代入を避けて、各要素を**独立した変数に分解**することで、矢印は直線的になる：

```
user <- premiumBonus
user <- couponBonus
base, premiumBonus, couponBonus <- score
```

再代入は「時間軸に沿った隠れた依存」を作り出すため、可能であれば避けた方がよい。

## 純粋関数や高階関数は矢印を減らすには？

依存の矢印を減らすには、例えば次のような方法がある
（これ以外にも、一般に言われている可読性向上のテクニックは、ほとんど依存関係の整理になっているはず

### 1. 小さな純粋関数を利用する

* 関数の出力は、**引数のみに依存**させる
* 外部状態（グローバル変数など）に依存しない
* 副作用を避ける

これにより、**関数の入出力だけが明示的な依存元・先**になる。

また、小さな関数に切り出すことで、内部の矢印は外からは見えなくなる。
これは**抽象化**であり、**複雑な依存を「ひとつの名前」に包んで隠す**行為だ。

```ts
const calculateFinalScore = (user) =>
  user.score + (user.premium ? 100 : 0);
```

### 2. 高階関数を使う

以下のような `map/filter/reduce` を使った構文は、**直線的な依存だけ**を持つ。

```ts
const result = data
  .filter(x => x.active)
  .map(x => x.value)
  .reduce((sum, x) => sum + x, 0);
```

各行は「ひとつ前の行」にだけ依存していて、それ以上には依存しない。
**矢印が一直線に並ぶ**構造は、読みやすく・壊れにくい。

矢印をイメージできるようになると、以下のような `for` 文は途端に最悪に思えてくるのではないだろうか。
```ts
let result = 0;

for (let i = 0; i < data.length; i++) {
  if (data[i].active) {
    result += data[i].value
  }
}
```

## まとめ

* コードには「依存の矢印」がある
* 矢印が多い・長い・隠れている・複雑なほど、コードは読みにくく壊れやすくなる
* グローバル変数や再代入は、矢印をねじれさせ・隠してしまう
* 純粋関数、高階関数、関数分割で、矢印を制御しよう

実装レベルのリファクタリングはつまるところ、**矢印のネットワークを構築・最適化する**ことだと思っている。

あなたにも、矢印は見えているだろうか？
